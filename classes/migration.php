<?php defined('SYSPATH') OR die('No direct access allowed.');
/**
 * Sprig migration abstract class.
 *
 * @package		Migration
 * @author		Oliver Morgan
 * @uses		DBForge
 * @copyright	(c) 2009 Oliver Morgan
 * @license		MIT
 */
abstract class Migration {
	
	/**
	 * Creates a new migration driver for a given model.
	 * 
	 * @throws	Kohana_Exception	If the migration driver couldn't be found.
	 * @param	mixed	The model identifier.
	 * @param	string	The migration driver.
	 * @return	object
	 */
	public static function factory($model, $driver = NULL)
	{
		// If the driver isnt given
		if ($driver === NULL)
		{
			// Check if the model is an object and an instance of the migratable model interface
			if ((is_object($model) OR $model = Model::factory($model)) AND $model instanceof Model_Migratable)
			{
				// If so, we can use the migratable interface
				return new Migration_Interface($model);
			}
			else
			{
				// Otherwise throw an exception
				throw new Kohana_Exception('Migration models given without a supported driver must implament the migratable interface.');
			}
		}
		
		// Get the name of the class from the driver
		$class = 'Migration_'.ucfirst($driver);
		
		// Check if the class exists
		if (class_exists($class))
		{
			// If it does then return an object
			return new $class($model);
		}
		
		// Throw an exception if a driver couldnt be found
		throw new Kohana_Exception('Migration driver :driver could not be found.', array(
			':driver'	=> $driver
		));
	}
	
	/**
	 * The database object
	 * 
	 * @var	Database
	 */
	protected $_db;
	
	/**
	 * The array of tables associated with the model.
	 * 
	 * @var	array
	 */
	protected $_tables;
	
	/**
	 * The model object.
	 * 
	 * @var	object
	 */
	protected $_model;
	
	/**
	 * The migration construct.
	 * 
	 * @param	mixed	An identifier used by the migration driver to get the model object.
	 */
	protected function __construct($model)
	{
		// Get the model object
		$this->_model = $this->_model($model);
		
		// Get the database object
		$this->_db = $this->_db();
		
		// Get the list of tables for this model
		$this->_tables = $this->_tables();
	}
	
	/**
	 * Removed existing tables and creates it again
	 * 
	 * @param	array	The options array given to the table(s) to compile with.
	 * @return	void
	 */
	public function rebuild(array $options = array())
	{
		// Remove the table then sync it
		$this->remove()->sync($options);
	}
	
	/**
	 * Remove all tables associated with the model if they already exist in the database.
	 * 
	 * @return	Migration
	 */
	public function remove()
	{
		// Loop through every table
		foreach ($this->_tables as $table)
		{
			// If the table exists
			if($table = Database_Table::instance($table->name, $this->_db))
			{
				// Then drop it
				DB::drop('table', $table->name)
					->execute($this->_db);
			}
		}
		
		// Return this for chaining
		return $this;
	}
	
	/**
	 * Syncs the model with the database schema.
	 * 
	 * @param	array	The options array given to the table(s) to compile with.
	 * @return	Migration
	 */
	public function sync(array $options = array())
	{
		// Loop through every table generated by the model.
		foreach ($this->_tables as $table)
		{
			// Search for any coresponding tables that exist in the database.
			$tables = $this->_db->list_tables($table->name);
			
			// List the key and value of the options array
			while (list($key, $value) = each($options))
			{
				// Adding them all to the table
				$table->add_option($key, $value);
			}
			
			if (empty($tables))
			{
				// If no coresponding tables were found, just create the table.
				$table->create();
			}
			else
			{
				// Begin an alter statement.
				$alter = DB::alter($table->name);
				
				// List the columns in the coresponding table
				$columns = $this->_db->list_columns($table->name);
				
				// Loop through columns in our table
				foreach ($table->columns() as $name => $column)
				{
					// If there is a coresponding column
					if (isset($columns[$column->name]))
					{
						// Modify it.
						DB::alter($table->name)
							->modify($column)
							->execute($this->_db);
					}
					else
					{
						// If there isnt, then add it.
						$alter->add($column);
					}
					
					// We have a reference of the column in our model, so unset it.
					unset($columns[$name]);
				}
				
				// Loop through everything that wasn't unset
				foreach ($columns as $name => $column)
				{
					// And drop it, because we don't have it in our model.
					DB::alter($table->name)
						->drop($name, 'column')
						->execute($this->_db);
				}
				
				// Execute the alter query if we have columns to add
				if ($alter->compile($this->_db))
				{
					$alter->execute($this->_db);
				}
			}
		}
		
		// Finally return the migration object.
		return $this;
	}
	
	/**
	 * Gets the model object associated with the model identifier.
	 * 
	 * @param	mixed	The model's identifier
	 * @return	object
	 */
	abstract protected function _model($model);
	
	/**
	 * Returns the database object used by the model.
	 * 
	 * @return	Database
	 */
	abstract protected function _db();
	
	/**
	 * Gets the array of tables generated by the model.
	 * 
	 * @return	array
	 */
	abstract protected function _tables();
	
} // End Migration